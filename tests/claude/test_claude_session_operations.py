"""
Claude Session Operations 模块的单元测试
测试 Session 的扫描和读取功能，特别是消息合并逻辑
"""

import json
import tempfile
from pathlib import Path

import pytest

from src.claude.claude_session_operations import ClaudeSessionOperations


class TestClaudeSessionOperations:
    """测试 ClaudeSessionOperations 类"""

    @pytest.fixture
    def temp_session_dir(self):
        """创建临时 session 目录"""
        with tempfile.TemporaryDirectory() as tmpdir:
            session_path = Path(tmpdir)
            session_path.mkdir(parents=True, exist_ok=True)
            yield session_path

    @pytest.fixture
    def session_ops(self, temp_session_dir):
        """创建 ClaudeSessionOperations 实例"""
        return ClaudeSessionOperations(temp_session_dir)

    @pytest.fixture
    def sample_session_data(self):
        """创建示例 session 数据"""
        return [
            # Meta 消息
            {
                "type": "meta",
                "sessionId": "test-session-123",
                "timestamp": "2026-01-12T10:00:00.000Z",
            },
            # User 消息
            {
                "type": "user",
                "userType": "external",
                "sessionId": "test-session-123",
                "timestamp": "2026-01-12T10:00:01.000Z",
                "cwd": "/test/project",
                "gitBranch": "main",
                "message": {
                    "role": "user",
                    "content": "请帮我搜索文件中的 @expose_api 定义",
                },
            },
            # Assistant 消息 - tool_use
            {
                "type": "assistant",
                "userType": "external",
                "sessionId": "test-session-123",
                "timestamp": "2026-01-12T10:00:02.000Z",
                "cwd": "/test/project",
                "gitBranch": "main",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_use",
                            "id": "call_abc123",
                            "name": "Grep",
                            "input": {
                                "pattern": "@expose_api",
                                "path": "/test/project/src",
                            },
                        }
                    ],
                },
            },
            # User 消息 - tool_result
            {
                "type": "user",
                "userType": "external",
                "sessionId": "test-session-123",
                "timestamp": "2026-01-12T10:00:03.000Z",
                "cwd": "/test/project",
                "gitBranch": "main",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_result",
                            "tool_use_id": "call_abc123",
                            "content": "Found 5 matches",
                        }
                    ],
                },
            },
            # Assistant 消息 - text
            {
                "type": "assistant",
                "userType": "external",
                "sessionId": "test-session-123",
                "timestamp": "2026-01-12T10:00:04.000Z",
                "cwd": "/test/project",
                "gitBranch": "main",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "text",
                            "text": "我找到了5个匹配项",
                        }
                    ],
                },
            },
        ]

    @pytest.fixture
    def sample_session_jsonl(self, temp_session_dir, sample_session_data):
        """创建示例 session JSONL 文件"""
        session_file = temp_session_dir / "test-session-123.jsonl"
        with open(session_file, "w", encoding="utf-8") as f:
            for message_data in sample_session_data:
                f.write(json.dumps(message_data) + "\n")
        return session_file

    # ========== 测试系统标签清理 ==========

    def test_clean_leading_system_tags_all_tags_at_start(self, session_ops):
        """测试清理消息开头的所有系统标签"""
        text = """<local-command-caveat>Caveat: The messages below were generated by the user while running local commands.</local-command-caveat>
<command-name>/clear</command-name>
<command-message>clear</command-message>
<command-args></command-args>
<local-command-stdout></local-command-stdout>
帮我调整 @.claude/commands/uiux_review.md 增加描述"""

        result = session_ops._clean_leading_system_tags(text)

        assert result == "帮我调整 @.claude/commands/uiux_review.md 增加描述"

    def test_clean_leading_system_tags_partial_tags(self, session_ops):
        """测试清理部分系统标签"""
        text = """<command-name>/test</command-name>
<command-message>test command</command-message>
This is actual content"""

        result = session_ops._clean_leading_system_tags(text)

        assert result == "This is actual content"

    def test_clean_leading_system_tags_tags_in_middle(self, session_ops):
        """测试不清理消息中间的系统标签"""
        text = """Some user content
<command-name>/test</command-name>
More content"""

        result = session_ops._clean_leading_system_tags(text)

        # 开头的用户内容应该保留
        assert result.startswith("Some user content")
        # 中间的标签也应该保留
        assert "<command-name>" in result

    def test_clean_leading_system_tags_no_tags(self, session_ops):
        """测试没有系统标签时直接返回原文本"""
        text = "This is normal user content without any tags"

        result = session_ops._clean_leading_system_tags(text)

        assert result == text

    def test_clean_leading_system_tags_empty_string(self, session_ops):
        """测试空字符串"""
        result = session_ops._clean_leading_system_tags("")

        assert result == ""

    def test_clean_leading_system_tags_only_tags(self, session_ops):
        """测试只有系统标签的情况"""
        text = """<local-command-caveat>Warning</local-command-caveat>
<command-name>/cmd</command-name>"""

        result = session_ops._clean_leading_system_tags(text)

        assert result == ""

    def test_clean_leading_system_tags_multiline_content(self, session_ops):
        """测试多行用户内容"""
        text = """<command-name>/clear</command-name>
<command-message>clear</command-message>
帮我调整 @.claude/commands/uiux_review.md 增加描述
针对折叠收起区块需要采样不同的折叠结构查看样式
以保证review 足够全面"""

        result = session_ops._clean_leading_system_tags(text)

        assert "帮我调整 @.claude/commands/uiux_review.md" in result
        assert "针对折叠收起区块需要采样不同的折叠结构" in result
        assert "以保证review 足够全面" in result

    def test_truncate_title_with_system_tags(self, session_ops):
        """测试 _truncate_title 能清理系统标签"""
        text = """<local-command-caveat>Warning</local-command-caveat>
<command-name>/test</command-name>
<command-message>test</command-message>
This is the actual title that should be extracted"""

        result = session_ops._truncate_title(text, 50)

        # 应该清理掉系统标签，并截断实际内容
        assert "<local-command-caveat>" not in result
        assert "<command-name>" not in result
        assert "This is the actual title" in result or result.startswith("This is")

    # ========== 测试 _merge_tool_result_to_tool_use ==========

    def test_merge_tool_result_to_tool_use_success(self, session_ops):
        """测试成功合并 tool_result 到 tool_use"""
        tool_use_map = {}
        tool_use_message = {
            "type": "assistant",
            "message": {
                "role": "assistant",
                "content": [
                    {
                        "type": "tool_use",
                        "id": "call_123",
                        "name": "Grep",
                        "input": {"pattern": "test"},
                    }
                ],
            },
        }
        tool_use_map["call_123"] = tool_use_message

        tool_result = {
            "type": "tool_result",
            "tool_use_id": "call_123",
            "content": "Found 10 matches",
        }

        session_ops._merge_tool_result_to_tool_use(tool_result, tool_use_map)

        # 验证合并结果
        tool_use_item = tool_use_message["message"]["content"][0]
        assert tool_use_item["output"] == "Found 10 matches"
        assert tool_use_item["status"] == "complete"
        # 注意：tool_use 不再从 map 中删除，以便后续的 isMeta 消息可以引用它
        assert "call_123" in tool_use_map

    def test_merge_tool_result_to_tool_use_not_found(self, session_ops, caplog):
        """测试 tool_result 找不到对应的 tool_use"""
        tool_use_map = {}
        tool_result = {
            "type": "tool_result",
            "tool_use_id": "call_unknown",
            "content": "Some result",
        }

        session_ops._merge_tool_result_to_tool_use(tool_result, tool_use_map)

        # 应该记录警告日志
        assert "not found in tool_use_map" in caplog.text

    # ========== 测试 _merge_meta_to_tool_use ==========

    def test_merge_meta_to_tool_use_success(self, session_ops):
        """测试成功合并 isMeta 消息到 tool_use（content 为字符串）"""
        tool_use_map = {}
        tool_use_message = {
            "type": "assistant",
            "message": {
                "role": "assistant",
                "content": [
                    {
                        "type": "tool_use",
                        "id": "call_123",
                        "name": "Grep",
                        "input": {"pattern": "test"},
                    }
                ],
            },
        }
        tool_use_map["call_123"] = tool_use_message

        # 创建 isMeta 消息，content 为字符串
        meta_message = {
            "isMeta": True,
            "sourceToolUseID": "call_123",
            "uuid": "meta-uuid-456",
            "timestamp": "2026-01-20T13:40:42.205Z",
            "type": "user",
            "message": {
                "role": "user",
                "content": "This is the meta text content",
            },
        }

        session_ops._merge_meta_to_tool_use(meta_message, tool_use_map)

        # 验证合并结果
        tool_use_item = tool_use_message["message"]["content"][0]
        assert "extra" in tool_use_item
        # extra 应该是字符串，包含 text 内容
        assert tool_use_item["extra"] == "This is the meta text content"

    def test_merge_meta_to_tool_use_not_found(self, session_ops, caplog):
        """测试 isMeta 消息找不到对应的 tool_use"""
        tool_use_map = {}
        meta_message = {
            "isMeta": True,
            "sourceToolUseID": "call_unknown",
            "uuid": "meta-uuid-789",
            "timestamp": "2026-01-20T13:40:42.205Z",
            "type": "user",
        }

        session_ops._merge_meta_to_tool_use(meta_message, tool_use_map)

        # 应该记录警告日志
        assert "not found in tool_use_map" in caplog.text

    def test_merge_meta_to_tool_use_filters_internal_fields(self, session_ops):
        """测试 isMeta 消息合并时只提取 text（content 为数组格式）"""
        tool_use_map = {}
        tool_use_message = {
            "type": "assistant",
            "message": {
                "role": "assistant",
                "content": [
                    {
                        "type": "tool_use",
                        "id": "call_456",
                        "name": "Read",
                        "input": {"file_path": "/test/file.txt"},
                    }
                ],
            },
        }
        tool_use_map["call_456"] = tool_use_message

        # content 为数组格式，包含 text 类型
        meta_message = {
            "isMeta": True,
            "sourceToolUseID": "call_456",
            "uuid": "meta-uuid-123",
            "timestamp": "2026-01-20T13:40:42.205Z",
            "type": "user",
            "message": {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": "Array format text content",
                    }
                ],
            },
        }

        session_ops._merge_meta_to_tool_use(meta_message, tool_use_map)

        # 验证 extra 是提取的 text 字符串
        tool_use_item = tool_use_message["message"]["content"][0]
        assert "extra" in tool_use_item
        assert tool_use_item["extra"] == "Array format text content"

    def test_merge_meta_to_tool_use_server_tool_use(self, session_ops):
        """测试 isMeta 消息合并到 server_tool_use"""
        tool_use_map = {}
        tool_use_message = {
            "type": "assistant",
            "message": {
                "role": "assistant",
                "content": [
                    {
                        "type": "server_tool_use",
                        "id": "server_call_789",
                        "name": "mcp__server__method",
                        "input": {"param": "value"},
                    }
                ],
            },
        }
        tool_use_map["server_call_789"] = tool_use_message

        meta_message = {
            "isMeta": True,
            "sourceToolUseID": "server_call_789",
            "uuid": "meta-uuid-999",
            "timestamp": "2026-01-20T13:40:42.205Z",
            "type": "user",
            "message": {
                "role": "user",
                "content": "Server tool use meta text",
            },
        }

        session_ops._merge_meta_to_tool_use(meta_message, tool_use_map)

        # 验证 server_tool_use 也能正确合并 extra
        tool_use_item = tool_use_message["message"]["content"][0]
        assert "extra" in tool_use_item
        assert tool_use_item["extra"] == "Server tool use meta text"

    # ========== 测试 _process_assistant_message ==========

    def test_process_assistant_message_with_tool_use(self, session_ops):
        """测试处理包含 tool_use 的 assistant 消息"""
        message_data = {
            "type": "assistant",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "assistant",
                "content": [
                    {
                        "type": "tool_use",
                        "id": "call_123",
                        "name": "Grep",
                        "input": {"pattern": "test"},
                    }
                ],
            },
        }

        tool_use_map = {}
        result = session_ops._process_assistant_message(message_data, tool_use_map)

        assert result["type"] == "assistant"
        tool_use_item = result["message"]["content"][0]
        assert tool_use_item["status"] == "incomplete"
        assert "call_123" in tool_use_map  # 应该被添加到 map 中

    def test_process_assistant_message_with_thinking(self, session_ops):
        """测试处理包含 thinking 的 assistant 消息"""
        message_data = {
            "type": "assistant",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "assistant",
                "content": [
                    {"type": "thinking", "thinking": "Let me think..."},
                ],
            },
        }

        tool_use_map = {}
        result = session_ops._process_assistant_message(message_data, tool_use_map)

        assert result["type"] == "assistant"
        # thinking 字段应该被转换为 text 字段
        thinking_item = result["message"]["content"][0]
        assert thinking_item["type"] == "thinking"
        assert thinking_item["text"] == "Let me think..."
        assert "thinking" not in thinking_item

    def test_process_assistant_message_empty_content(self, session_ops):
        """测试处理空 content 的消息"""
        message_data = {
            "type": "assistant",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {"role": "assistant", "content": []},
        }

        tool_use_map = {}
        result = session_ops._process_assistant_message(message_data, tool_use_map)

        # 应该返回原始消息
        assert result is message_data

    # ========== 测试 _convert_command_message ==========

    def test_convert_command_message_with_meta(self, session_ops):
        """测试转换 command 消息（有 isMeta 后续消息）"""
        command_message = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "user",
                "content": "<command-message>code-review:code-review</command-message>\n<command-name>/code-review:code-review</command-name>",
            },
        }

        meta_message = {
            "type": "user",
            "isMeta": True,
            "timestamp": "2024-01-01T10:00:01Z",
            "message": {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": "Provide a code review for the given pull request.",
                    }
                ],
            },
        }

        result = session_ops._convert_command_message(command_message, meta_message)

        assert result is not None
        assert result["type"] == "user"
        assert result["message"]["role"] == "user"
        content = result["message"]["content"]
        assert len(content) == 1
        assert content[0]["type"] == "command"
        assert content[0]["command"] == "/code-review:code-review"
        assert (
            content[0]["content"] == "Provide a code review for the given pull request."
        )
        assert result["_converted"] is True
        assert result["_original_type"] == "command"
        # 验证原始 meta 消息被标记为跳过
        assert meta_message.get("_skipped_next") is True

    def test_convert_command_message_without_meta(self, session_ops):
        """测试转换 command 消息（没有 isMeta 后续消息）"""
        command_message = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "user",
                "content": "<command-message>test-command</command-message>\n<command-name>/test</command-name>",
            },
        }

        result = session_ops._convert_command_message(command_message, None)

        assert result is not None
        assert result["type"] == "user"
        content = result["message"]["content"]
        assert len(content) == 1
        assert content[0]["type"] == "command"
        assert content[0]["command"] == "/test"
        assert content[0]["content"] == ""

    def test_convert_command_message_non_command(self, session_ops):
        """测试非 command 消息不被转换"""
        normal_message = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {"role": "user", "content": "This is a normal message"},
        }

        result = session_ops._convert_command_message(normal_message, None)

        assert result is None

    def test_convert_command_message_empty_content(self, session_ops):
        """测试空 content 的消息不被转换"""
        message_with_empty_content = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {"role": "user", "content": []},
        }

        result = session_ops._convert_command_message(message_with_empty_content, None)

        assert result is None

    def test_convert_command_message_partial_tags(self, session_ops):
        """测试只有部分 command 标签的消息不被转换"""
        partial_command_message = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "user",
                "content": "<command-message>test</command-message>",
            },
        }

        result = session_ops._convert_command_message(partial_command_message, None)

        assert result is None

    def test_convert_command_message_with_extra_text(self, session_ops):
        """测试 command 标签前后有额外文本时不会被转换"""
        message_with_extra = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "user",
                "content": "Please help me <command-message>test</command-message>\n<command-name>/test</command-name>",
            },
        }

        result = session_ops._convert_command_message(message_with_extra, None)

        assert result is None

    def test_convert_command_message_embedded_in_text(self, session_ops):
        """测试 command 标签嵌入在文本中间时不会被转换"""
        embedded_message = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "user",
                "content": "<command-message>test</command-message>\n<command-name>/test</command-name> and then do something else",
            },
        }

        result = session_ops._convert_command_message(embedded_message, None)

        assert result is None

    def test_convert_command_message_whitespace_variations(self, session_ops):
        """测试不同空白格变体应该被正确识别"""
        # 只有换行符
        message_with_newline = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "user",
                "content": "<command-message>test</command-message>\n<command-name>/test</command-name>",
            },
        }

        result = session_ops._convert_command_message(message_with_newline, None)
        assert result is not None
        assert result["message"]["content"][0]["command"] == "/test"

        # 多个换行符和空格
        message_with_spaces = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {
                "role": "user",
                "content": "<command-message>test</command-message>\n  \n<command-name>/test2</command-name>  ",
            },
        }

        result = session_ops._convert_command_message(message_with_spaces, None)
        assert result is not None
        assert result["message"]["content"][0]["command"] == "/test2"

    # ========== 测试 _merge_tool_use_with_result ==========

    @pytest.mark.asyncio
    async def test_merge_tool_use_with_result_complete(
        self, session_ops, sample_session_data
    ):
        """测试完整的 tool_use 和 tool_result 合并流程"""
        # 提取消息部分
        messages = [m for m in sample_session_data if "message" in m]

        # 执行合并
        merged = session_ops._merge_tool_use_with_result(messages)

        # 验证合并结果
        # 应该有 3 条消息（user + assistant with merged tool_use + assistant with text）
        assert len(merged) == 3

        # 第一条是 user 消息
        assert merged[0]["type"] == "user"
        assert merged[0]["message"]["role"] == "user"

        # 第二条是 assistant 消息，包含合并后的 tool_use
        assistant_msg_1 = merged[1]
        assert assistant_msg_1["type"] == "assistant"
        assert assistant_msg_1["message"]["role"] == "assistant"
        content = assistant_msg_1["message"]["content"]
        assert len(content) == 1

        # 验证合并后的 tool_use
        tool_use = content[0]
        assert tool_use["type"] == "tool_use"
        assert tool_use["id"] == "call_abc123"
        assert tool_use["name"] == "Grep"
        assert tool_use["input"] == {
            "pattern": "@expose_api",
            "path": "/test/project/src",
        }
        assert tool_use["output"] == "Found 5 matches"
        assert tool_use["status"] == "complete"

        # 第三条是 assistant 消息，包含 text
        assistant_msg_2 = merged[2]
        assert assistant_msg_2["type"] == "assistant"
        assert assistant_msg_2["message"]["role"] == "assistant"
        text_content = assistant_msg_2["message"]["content"]
        assert len(text_content) == 1
        assert text_content[0]["type"] == "text"

    @pytest.mark.asyncio
    async def test_merge_tool_use_without_result(self, session_ops):
        """测试没有 tool_result 的 tool_use（incomplete）"""
        messages = [
            {
                "type": "assistant",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_use",
                            "id": "call_xyz789",
                            "name": "ReadFile",
                            "input": {"file_path": "/test/file.txt"},
                        }
                    ],
                },
            }
        ]

        merged = session_ops._merge_tool_use_with_result(messages)

        assert len(merged) == 1
        tool_use = merged[0]["message"]["content"][0]
        assert tool_use["type"] == "tool_use"
        assert tool_use["status"] == "incomplete"
        assert "output" not in tool_use

    @pytest.mark.asyncio
    async def test_merge_multiple_tool_uses(self, session_ops):
        """测试多个 tool_use 的合并"""
        messages = [
            {
                "type": "assistant",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_use",
                            "id": "call_1",
                            "name": "Grep",
                            "input": {"pattern": "test"},
                        },
                        {
                            "type": "tool_use",
                            "id": "call_2",
                            "name": "ReadFile",
                            "input": {"file_path": "test.txt"},
                        },
                    ],
                },
            },
            {
                "type": "user",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_result",
                            "tool_use_id": "call_1",
                            "content": "Found 3 matches",
                        }
                    ],
                },
            },
            {
                "type": "user",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_result",
                            "tool_use_id": "call_2",
                            "content": "File content loaded",
                        }
                    ],
                },
            },
        ]

        merged = session_ops._merge_tool_use_with_result(messages)

        # 应该只有 1 条消息（两个 tool_use 都合并到同一 assistant 消息中）
        assert len(merged) == 1
        content = merged[0]["message"]["content"]
        assert len(content) == 2

        # 验证第一个 tool_use
        assert content[0]["type"] == "tool_use"
        assert content[0]["id"] == "call_1"
        assert content[0]["status"] == "complete"
        assert content[0]["output"] == "Found 3 matches"

        # 验证第二个 tool_use
        assert content[1]["type"] == "tool_use"
        assert content[1]["id"] == "call_2"
        assert content[1]["status"] == "complete"
        assert content[1]["output"] == "File content loaded"

    @pytest.mark.asyncio
    async def test_merge_command_message_with_meta(self, session_ops):
        """测试完整的 command 消息合并流程（有 isMeta 消息）"""
        messages = [
            {
                "type": "user",
                "timestamp": "2024-01-01T10:00:00Z",
                "message": {
                    "role": "user",
                    "content": "<command-message>code-review:code-review</command-message>\n<command-name>/code-review:code-review</command-name>",
                },
            },
            {
                "type": "user",
                "isMeta": True,
                "timestamp": "2024-01-01T10:00:01Z",
                "message": {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": "Provide a detailed code review of the PR.",
                        }
                    ],
                },
            },
            {
                "type": "user",
                "timestamp": "2024-01-01T10:00:02Z",
                "message": {"role": "user", "content": "Normal user message"},
            },
        ]

        merged = session_ops._merge_tool_use_with_result(messages)

        # 应该有 2 条消息（command + normal user message）
        assert len(merged) == 2

        # 第一条是 command 消息
        command_msg = merged[0]
        assert command_msg["type"] == "user"
        assert command_msg["message"]["role"] == "user"
        content = command_msg["message"]["content"]
        assert len(content) == 1
        assert content[0]["type"] == "command"
        assert content[0]["command"] == "/code-review:code-review"
        assert content[0]["content"] == "Provide a detailed code review of the PR."

        # 第二条是普通 user 消息
        normal_msg = merged[1]
        assert normal_msg["type"] == "user"
        # 字符串类型的 content 会被转换为 [{type: "text", text: "..."}] 格式
        normal_content = normal_msg["message"]["content"]
        assert isinstance(normal_content, list)
        assert normal_content[0]["type"] == "text"
        assert normal_content[0]["text"] == "Normal user message"

    @pytest.mark.asyncio
    async def test_merge_command_message_without_meta(self, session_ops):
        """测试 command 消息合并流程（没有 isMeta 消息）"""
        messages = [
            {
                "type": "user",
                "timestamp": "2024-01-01T10:00:00Z",
                "message": {
                    "role": "user",
                    "content": "<command-message>test</command-message>\n<command-name>/test</command-name>",
                },
            },
        ]

        merged = session_ops._merge_tool_use_with_result(messages)

        # 应该有 1 条 command 消息
        assert len(merged) == 1
        command_msg = merged[0]
        assert command_msg["type"] == "user"
        content = command_msg["message"]["content"]
        assert content[0]["type"] == "command"
        assert content[0]["command"] == "/test"
        assert content[0]["content"] == ""

    @pytest.mark.asyncio
    async def test_merge_ismeta_message_to_tool_use(self, session_ops):
        """测试完整的 isMeta 消息合并到 tool_use 的流程"""
        messages = [
            # Assistant 消息，包含 tool_use
            {
                "type": "assistant",
                "timestamp": "2024-01-01T10:00:00Z",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_use",
                            "id": "call_abc123",
                            "name": "Grep",
                            "input": {
                                "pattern": "@expose_api",
                                "path": "/test/project/src",
                            },
                        }
                    ],
                },
            },
            # isMeta 消息（包含 sourceToolUseID）
            {
                "type": "user",
                "isMeta": True,
                "sourceToolUseID": "call_abc123",
                "uuid": "8d4d59dc-85df-4057-b95e-81604c7c95ea",
                "timestamp": "2026-01-20T13:40:42.205Z",
                "message": {
                    "role": "user",
                    "content": "This is the metadata text",
                },
            },
            # User 消息 - tool_result
            {
                "type": "user",
                "timestamp": "2024-01-01T10:00:03.000Z",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_result",
                            "tool_use_id": "call_abc123",
                            "content": "Found 5 matches",
                        }
                    ],
                },
            },
        ]

        merged = session_ops._merge_tool_use_with_result(messages)

        # 应该有 1 条消息（tool_use 已合并 tool_result 和 isMeta）
        assert len(merged) == 1

        # 验证 assistant 消息，包含合并后的 tool_use
        assistant_msg = merged[0]
        assert assistant_msg["type"] == "assistant"
        assert assistant_msg["message"]["role"] == "assistant"
        content = assistant_msg["message"]["content"]
        assert len(content) == 1

        # 验证合并后的 tool_use
        tool_use = content[0]
        assert tool_use["type"] == "tool_use"
        assert tool_use["id"] == "call_abc123"
        assert tool_use["name"] == "Grep"
        assert tool_use["input"] == {
            "pattern": "@expose_api",
            "path": "/test/project/src",
        }
        assert tool_use["output"] == "Found 5 matches"
        assert tool_use["status"] == "complete"

        # 验证 extra 字段包含提取的 text 内容
        assert "extra" in tool_use
        assert tool_use["extra"] == "This is the metadata text"

    @pytest.mark.asyncio
    async def test_merge_ismeta_message_without_source_tool_use_id(self, session_ops):
        """测试 isMeta 消息没有 sourceToolUseID 时不被处理"""
        messages = [
            # Assistant 消息，包含 tool_use
            {
                "type": "assistant",
                "timestamp": "2024-01-01T10:00:00Z",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_use",
                            "id": "call_test",
                            "name": "Grep",
                            "input": {"pattern": "test"},
                        }
                    ],
                },
            },
            # isMeta 消息但没有 sourceToolUseID（不应该被合并）
            {
                "type": "user",
                "isMeta": True,
                "uuid": "meta-uuid-123",
                "timestamp": "2026-01-20T13:40:42.205Z",
                "metadata": "value",
            },
        ]

        merged = session_ops._merge_tool_use_with_result(messages)

        # 应该有 1 条消息
        assert len(merged) == 1

        # 验证 tool_use 没有 extra 字段（因为没有 sourceToolUseID）
        tool_use = merged[0]["message"]["content"][0]
        assert "extra" not in tool_use

    # ========== 测试 scan_sessions ==========

    @pytest.mark.asyncio
    async def test_scan_sessions_empty(self, session_ops):
        """测试扫描空的 session 目录"""
        sessions = await session_ops.scan_sessions()

        assert sessions == []
        assert isinstance(sessions, list)

    @pytest.mark.asyncio
    async def test_scan_sessions_success(self, temp_session_dir, session_ops):
        """测试成功扫描 session 列表"""
        # 创建多个 session 文件
        sessions_to_create = [
            "session-1.jsonl",
            "session-2.jsonl",
            "agent-session-3.jsonl",
        ]

        for session_name in sessions_to_create:
            session_file = temp_session_dir / session_name
            with open(session_file, "w", encoding="utf-8") as f:
                f.write(
                    json.dumps(
                        {
                            "type": "user",
                            "message": {"role": "user", "content": "test"},
                        }
                    )
                    + "\n"
                )

        sessions = await session_ops.scan_sessions()

        assert len(sessions) == 3

        # 验证 session 信息
        session_ids = [s.session_id for s in sessions]
        assert "session-1" in session_ids
        assert "session-2" in session_ids
        assert "agent-session-3" in session_ids

        # 验证 is_agent_session 标记
        agent_session = next(s for s in sessions if s.session_id == "agent-session-3")
        assert agent_session.is_agent_session is True

        normal_session = next(s for s in sessions if s.session_id == "session-1")
        assert normal_session.is_agent_session is False

    @pytest.mark.asyncio
    async def test_scan_sessions_nonexistent_directory(self):
        """测试扫描不存在的目录"""
        nonexistent_path = Path("/tmp/this-directory-does-not-exist-12345")
        ops = ClaudeSessionOperations(nonexistent_path)

        sessions = await ops.scan_sessions()

        # 不存在的目录应该返回空列表
        assert sessions == []

    @pytest.mark.asyncio
    async def test_scan_sessions_incremental(self, temp_session_dir, session_ops):
        """测试增量扫描（使用现有 title）"""
        # 创建一个 session 文件
        session_file = temp_session_dir / "session-1.jsonl"
        with open(session_file, "w", encoding="utf-8") as f:
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "message": {"role": "user", "content": "Test message"},
                    }
                )
                + "\n"
            )

        # 第一次扫描（需要读取文件）
        sessions_first = await session_ops.scan_sessions()
        assert len(sessions_first) == 1
        assert sessions_first[0].title is not None

        # 第二次扫描（传入现有 title，应该跳过读取）
        existing_titles = {s.session_id: s.title for s in sessions_first}
        sessions_second = await session_ops.scan_sessions(existing_titles)
        assert len(sessions_second) == 1
        assert sessions_second[0].title == sessions_first[0].title

    @pytest.mark.asyncio
    async def test_scan_sessions_filter_without_title(
        self, temp_session_dir, session_ops
    ):
        """测试过滤没有标题的 session"""
        # 创建多个 session 文件
        sessions_to_create = [
            ("session-with-title.jsonl", "This session has a title"),
            ("session-without-title.jsonl", None),  # 会创建空文件或只有 meta 消息的文件
            ("agent-session.jsonl", "Agent session title"),
        ]

        for session_name, content in sessions_to_create:
            session_file = temp_session_dir / session_name
            with open(session_file, "w", encoding="utf-8") as f:
                if content:
                    # 写入有内容的用户消息
                    f.write(
                        json.dumps(
                            {
                                "type": "user",
                                "message": {"role": "user", "content": content},
                            }
                        )
                        + "\n"
                    )
                else:
                    # 只写入 meta 消息（不会被提取为标题）
                    f.write(
                        json.dumps(
                            {
                                "type": "meta",
                                "sessionId": "test-session",
                                "timestamp": "2026-01-12T10:00:00.000Z",
                            }
                        )
                        + "\n"
                    )

        sessions = await session_ops.scan_sessions()

        # 应该只返回有标题的 session（过滤掉了 session-without-title）
        assert len(sessions) == 2
        session_ids = [s.session_id for s in sessions]
        assert "session-with-title" in session_ids
        assert "agent-session" in session_ids
        assert "session-without-title" not in session_ids

    @pytest.mark.asyncio
    async def test_scan_sessions_filter_empty_content(
        self, temp_session_dir, session_ops
    ):
        """测试过滤只有 Warmup 消息的 session"""
        # 创建一个只有 Warmup 消息的 session
        session_file = temp_session_dir / "session-warmup-only.jsonl"
        with open(session_file, "w", encoding="utf-8") as f:
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "message": {"role": "user", "content": "Warmup"},
                    }
                )
                + "\n"
            )

        # 创建一个正常的 session
        normal_session = temp_session_dir / "session-normal.jsonl"
        with open(normal_session, "w", encoding="utf-8") as f:
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "message": {"role": "user", "content": "Normal message"},
                    }
                )
                + "\n"
            )

        sessions = await session_ops.scan_sessions()

        # Warmup-only session 应该被过滤掉
        assert len(sessions) == 1
        assert sessions[0].session_id == "session-normal"

    @pytest.mark.asyncio
    async def test_scan_sessions_with_existing_titles_filtering(
        self, temp_session_dir, session_ops
    ):
        """测试使用 existing_titles 时的过滤逻辑"""
        # 创建一个有标题的 session
        session_file = temp_session_dir / "session-1.jsonl"
        with open(session_file, "w", encoding="utf-8") as f:
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "message": {"role": "user", "content": "Test message"},
                    }
                )
                + "\n"
            )

        # 传入包含 None title 的 existing_titles
        existing_titles = {
            "session-1": "Existing Title",
            "session-2": None,  # 没有 title 的应该被过滤
        }

        sessions = await session_ops.scan_sessions(existing_titles)

        # 即使传入了 None title，也只会返回实际存在且有标题的 session
        assert len(sessions) == 1
        assert sessions[0].session_id == "session-1"
        assert sessions[0].title == "Existing Title"

    # ========== 测试 _load_session_data ==========

    @pytest.mark.asyncio
    async def test_load_session_data_success(self, session_ops, sample_session_jsonl):
        """测试成功加载 session 数据"""
        session, _ = await session_ops._load_session_data(sample_session_jsonl)

        assert session is not None
        assert session.session_id == "test-session-123"
        assert session.session_file == str(sample_session_jsonl)
        assert session.is_agent_session is False
        # meta 消息被过滤掉了，只剩余 user 和 assistant 消息
        assert session.message_count == 2

    @pytest.mark.asyncio
    async def test_load_session_data_agent_session(self, temp_session_dir):
        """测试加载 agent session"""
        session_file = temp_session_dir / "agent-test-456.jsonl"
        with open(session_file, "w", encoding="utf-8") as f:
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "message": {"role": "user", "content": "test"},
                    }
                )
                + "\n"
            )

        ops = ClaudeSessionOperations(temp_session_dir)
        session, _ = await ops._load_session_data(session_file)

        assert session is not None
        assert session.is_agent_session is True
        assert session.session_id == "agent-test-456"

    @pytest.mark.asyncio
    async def test_load_session_data_invalid_json(self, temp_session_dir):
        """测试加载无效的 JSON 文件"""
        session_file = temp_session_dir / "invalid.jsonl"
        with open(session_file, "w", encoding="utf-8") as f:
            f.write("invalid json content")

        ops = ClaudeSessionOperations(temp_session_dir)
        session, _ = await ops._load_session_data(session_file)

        assert session is None

    @pytest.mark.asyncio
    async def test_load_session_data_empty_file(self, temp_session_dir):
        """测试加载空文件"""
        session_file = temp_session_dir / "empty.jsonl"
        session_file.touch()

        ops = ClaudeSessionOperations(temp_session_dir)
        session, _ = await ops._load_session_data(session_file)

        # 空文件应该返回 None（没有有效消息）
        assert session is None

    # ========== 测试 read_session_contents ==========

    @pytest.mark.asyncio
    async def test_read_session_contents_success(
        self, session_ops, sample_session_jsonl
    ):
        """测试成功读取 session 内容"""
        session = await session_ops.read_session_contents("test-session-123")

        assert session is not None
        assert session.session_id == "test-session-123"
        # meta 消息被过滤掉了，只剩余 user 和 assistant 消息
        assert len(session.messages) == 2

        # 验证合并后的 tool_use
        tool_use_msg = session.messages[1]
        content = tool_use_msg.message.get("content")
        tool_use = next(
            (
                item
                for item in content
                if isinstance(item, dict) and item.get("type") == "tool_use"
            ),
            None,
        )
        assert tool_use is not None
        assert tool_use["status"] == "complete"
        assert tool_use["output"] == "Found 5 matches"

    @pytest.mark.asyncio
    async def test_read_session_contents_not_found(self, session_ops):
        """测试读取不存在的 session"""
        session = await session_ops.read_session_contents("nonexistent-session")

        assert session is None

    @pytest.mark.asyncio
    async def test_read_session_contents_invalid_id(self, session_ops):
        """测试使用无效的 session_id（路径遍历攻击）"""
        with pytest.raises(ValueError, match="Invalid session_id"):
            await session_ops.read_session_contents("../etc/passwd")

    # ========== 测试 detect_project_info ==========

    @pytest.mark.asyncio
    async def test_detect_project_info_success(self, temp_session_dir):
        """测试成功检测项目路径和时间"""
        # 创建包含 cwd 的 session 文件
        session_file = temp_session_dir / "session-1.jsonl"
        with open(session_file, "w") as f:
            f.write(
                json.dumps(
                    {"timestamp": "2024-01-01T10:00:00Z", "cwd": "/test/project"}
                )
                + "\n"
            )

        ops = ClaudeSessionOperations(temp_session_dir)
        project_path, last_active = await ops.detect_project_info()

        assert project_path == "/test/project"
        assert last_active is not None

    @pytest.mark.asyncio
    async def test_detect_project_info_not_found(self, temp_session_dir):
        """测试找不到项目路径"""
        # 创建不包含 cwd 的 session 文件
        session_file = temp_session_dir / "session-1.jsonl"
        with open(session_file, "w") as f:
            f.write(json.dumps({"timestamp": "2024-01-01T10:00:00Z"}) + "\n")

        ops = ClaudeSessionOperations(temp_session_dir)
        project_path, last_active = await ops.detect_project_info()

        assert project_path is None
        assert last_active is None

    # ========== 测试 _read_session_title ==========

    @pytest.mark.asyncio
    async def test_read_session_title_with_command(self, temp_session_dir):
        """测试从 command 消息中提取标题"""
        session_file = temp_session_dir / "session-command.jsonl"
        with open(session_file, "w", encoding="utf-8") as f:
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "timestamp": "2024-01-01T10:00:00Z",
                        "message": {
                            "role": "user",
                            "content": "<command-message>code-review:code-review</command-message>\n<command-name>/code-review:code-review</command-name>",
                        },
                    }
                )
                + "\n"
            )

        ops = ClaudeSessionOperations(temp_session_dir)
        title, line_number = await ops._read_session_title(session_file)

        assert title == "/code-review:code-review"
        assert line_number == 1

    @pytest.mark.asyncio
    async def test_read_session_title_command_truncated(self, temp_session_dir):
        """测试 command 名称被截断"""
        session_file = temp_session_dir / "session-command-long.jsonl"
        long_command_name = (
            "/very:long:command:name:that:exceeds:default:max:length:limit"
        )
        with open(session_file, "w", encoding="utf-8") as f:
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "timestamp": "2024-01-01T10:00:00Z",
                        "message": {
                            "role": "user",
                            "content": f"<command-message>test</command-message>\n<command-name>{long_command_name}</command-name>",
                        },
                    }
                )
                + "\n"
            )

        ops = ClaudeSessionOperations(temp_session_dir)
        title, line_number = await ops._read_session_title(session_file)

        # 默认最大长度是 50，所以应该被截断
        assert title is not None
        assert len(title) <= 50
        assert title.endswith("...")
        assert long_command_name.startswith(title[:-3])

    @pytest.mark.asyncio
    async def test_read_session_title_normal_message_after_command(
        self, temp_session_dir
    ):
        """测试 command 消息优先于普通消息被用作标题"""
        session_file = temp_session_dir / "session-mixed.jsonl"
        with open(session_file, "w", encoding="utf-8") as f:
            # 写入一条 command 消息
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "timestamp": "2024-01-01T10:00:00Z",
                        "message": {
                            "role": "user",
                            "content": "<command-message>test</command-message>\n<command-name>/test</command-name>",
                        },
                    }
                )
                + "\n"
            )
            # 写入一条普通消息
            f.write(
                json.dumps(
                    {
                        "type": "user",
                        "timestamp": "2024-01-01T10:00:01Z",
                        "message": {"role": "user", "content": "Normal message"},
                    }
                )
                + "\n"
            )

        ops = ClaudeSessionOperations(temp_session_dir)
        title, line_number = await ops._read_session_title(session_file)

        # 应该使用 command 名称作为标题
        assert title == "/test"
        assert line_number == 1

    @pytest.mark.asyncio
    async def test_extract_command_name_success(self, session_ops):
        """测试成功提取 command 名称"""
        content = "<command-message>code-review:code-review</command-message>\n<command-name>/code-review:code-review</command-name>"
        result = session_ops._extract_command_name(content)

        assert result == "/code-review:code-review"

    def test_extract_command_name_non_command(self, session_ops):
        """测试非 command 消息返回 None"""
        content = "This is a normal message"
        result = session_ops._extract_command_name(content)

        assert result is None

    def test_extract_command_name_partial_tags(self, session_ops):
        """测试只有部分标签返回 None"""
        content = "<command-message>test</command-message>"
        result = session_ops._extract_command_name(content)

        assert result is None

    def test_extract_command_name_with_extra_text(self, session_ops):
        """测试 command 标签前后有额外文本时返回 None"""
        content = "Please help <command-message>test</command-message>\n<command-name>/test</command-name>"
        result = session_ops._extract_command_name(content)

        assert result is None

    def test_extract_command_name_embedded_in_text(self, session_ops):
        """测试 command 标签嵌入在文本中间时返回 None"""
        content = "<command-message>test</command-message>\n<command-name>/test</command-name> and then more text"
        result = session_ops._extract_command_name(content)

        assert result is None

    def test_extract_command_name_with_prefix_text(self, session_ops):
        """测试 command 标签前有文本时返回 None"""
        content = "prefix <command-message>test</command-message>\n<command-name>/test</command-name>"
        result = session_ops._extract_command_name(content)

        assert result is None

    def test_extract_command_name_exact_match(self, session_ops):
        """测试完全匹配标准格式"""
        content = "<command-message>test</command-message>\n<command-name>/exact-match</command-name>"
        result = session_ops._extract_command_name(content)

        assert result == "/exact-match"

    def test_extract_command_name_with_trailing_spaces(self, session_ops):
        """测试尾部有空格应该被 strip 后匹配"""
        content = "<command-message>test</command-message>\n<command-name>/trailing</command-name>  "
        result = session_ops._extract_command_name(content)

        assert result == "/trailing"

    def test_extract_command_name_empty_string(self, session_ops):
        """测试空字符串返回 None"""
        result = session_ops._extract_command_name("")
        assert result is None

    def test_extract_command_name_non_string_input(self, session_ops):
        """测试非字符串输入返回 None"""
        result = session_ops._extract_command_name(["list", "content"])
        assert result is None

        result = session_ops._extract_command_name({"type": "object"})
        assert result is None

    # ========== 测试 progress 消息处理 ==========

    def test_convert_progress_message_to_standard_user(self, session_ops):
        """测试转换 user 类型的 progress 消息"""
        progress_msg = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
            "uuid": "test-uuid-123",
            "message": {
                "role": "user",
                "content": "Please review this code",
            },
        }

        result = session_ops._convert_progress_message_to_standard(progress_msg)

        assert result is not None
        assert result["type"] == "user"
        assert result["timestamp"] == "2024-01-01T10:00:00Z"
        assert result["uuid"] == "test-uuid-123"
        assert result["message"]["role"] == "user"
        assert result["_from_subagent"] is True
        assert result["_subagent"] is True

    def test_convert_progress_message_to_standard_assistant(self, session_ops):
        """测试转换 assistant 类型的 progress 消息"""
        progress_msg = {
            "type": "assistant",
            "timestamp": "2024-01-01T10:00:01Z",
            "uuid": "test-uuid-456",
            "message": {
                "role": "assistant",
                "content": [
                    {
                        "type": "text",
                        "text": "I'll review the code for you",
                    }
                ],
            },
        }

        result = session_ops._convert_progress_message_to_standard(progress_msg)

        assert result is not None
        assert result["type"] == "assistant"
        assert result["message"]["role"] == "assistant"
        assert result["_from_subagent"] is True

    def test_convert_progress_message_to_standard_system(self, session_ops):
        """测试转换 system 类型的 progress 消息"""
        progress_msg = {
            "type": "system",
            "timestamp": "2024-01-01T10:00:02Z",
            "uuid": "test-uuid-789",
            "message": {
                "role": "system",
                "content": "System message",
            },
        }

        result = session_ops._convert_progress_message_to_standard(progress_msg)

        assert result is not None
        assert result["type"] == "system"
        assert result["message"]["role"] == "system"

    def test_convert_progress_message_to_standard_invalid_type(self, session_ops):
        """测试无效类型的 progress 消息返回 None"""
        progress_msg = {
            "type": "invalid_type",
            "timestamp": "2024-01-01T10:00:00Z",
            "message": {"role": "user", "content": "test"},
        }

        result = session_ops._convert_progress_message_to_standard(progress_msg)

        assert result is None

    def test_convert_progress_message_to_standard_no_message(self, session_ops):
        """测试没有 message 字段的 progress 消息返回 None"""
        progress_msg = {
            "type": "user",
            "timestamp": "2024-01-01T10:00:00Z",
        }

        result = session_ops._convert_progress_message_to_standard(progress_msg)

        assert result is None

    def test_convert_progress_message_to_standard_non_dict(self, session_ops):
        """测试非 dict 输入返回 None"""
        result = session_ops._convert_progress_message_to_standard(None)
        assert result is None

        result = session_ops._convert_progress_message_to_standard("string")
        assert result is None

    def test_extract_progress_messages_single_subagent(self, session_ops):
        """测试提取单个 subagent 的 progress 消息"""
        raw_messages = [
            {
                "type": "progress",
                "parentToolUseID": "call_123",
                "data": {
                    "normalizedMessages": [
                        {
                            "type": "user",
                            "timestamp": "2024-01-01T10:00:00Z",
                            "uuid": "msg-1",
                            "message": {"role": "user", "content": "Help me"},
                        },
                        {
                            "type": "assistant",
                            "timestamp": "2024-01-01T10:00:01Z",
                            "uuid": "msg-2",
                            "message": {
                                "role": "assistant",
                                "content": [{"type": "text", "text": "OK"}],
                            },
                        },
                    ]
                },
            },
        ]

        result = session_ops._extract_progress_messages(raw_messages)

        assert len(result) == 1
        assert "call_123" in result
        assert len(result["call_123"]) == 2

        # 验证第一条消息
        msg1 = result["call_123"][0]
        assert msg1["type"] == "user"
        assert msg1["uuid"] == "msg-1"
        assert msg1["_from_subagent"] is True

        # 验证第二条消息
        msg2 = result["call_123"][1]
        assert msg2["type"] == "assistant"
        assert msg2["uuid"] == "msg-2"
        assert msg2["_from_subagent"] is True

    def test_extract_progress_messages_multiple_subagents(self, session_ops):
        """测试提取多个 subagent 的 progress 消息"""
        raw_messages = [
            {
                "type": "progress",
                "parentToolUseID": "call_1",
                "data": {
                    "normalizedMessages": [
                        {
                            "type": "user",
                            "uuid": "msg-1",
                            "message": {"role": "user", "content": "Task 1"},
                        }
                    ]
                },
            },
            {
                "type": "progress",
                "parentToolUseID": "call_2",
                "data": {
                    "normalizedMessages": [
                        {
                            "type": "user",
                            "uuid": "msg-2",
                            "message": {"role": "user", "content": "Task 2"},
                        }
                    ]
                },
            },
        ]

        result = session_ops._extract_progress_messages(raw_messages)

        assert len(result) == 2
        assert "call_1" in result
        assert "call_2" in result
        assert len(result["call_1"]) == 1
        assert len(result["call_2"]) == 1

    def test_extract_progress_messages_deduplication(self, session_ops):
        """测试 progress 消息去重"""
        raw_messages = [
            {
                "type": "progress",
                "parentToolUseID": "call_123",
                "data": {
                    "normalizedMessages": [
                        {
                            "type": "user",
                            "uuid": "msg-1",
                            "message": {"role": "user", "content": "Same message"},
                        }
                    ],
                },
            },
            {
                "type": "progress",
                "parentToolUseID": "call_123",
                "data": {
                    "normalizedMessages": [
                        {
                            "type": "user",
                            "uuid": "msg-1",  # 相同 uuid，应该被去重
                            "message": {"role": "user", "content": "Same message"},
                        },
                        {
                            "type": "assistant",
                            "uuid": "msg-2",
                            "message": {"role": "assistant", "content": "New message"},
                        },
                    ],
                },
            },
        ]

        result = session_ops._extract_progress_messages(raw_messages)

        assert len(result) == 1
        assert len(result["call_123"]) == 2  # 应该只有 2 条消息（去重后）

    def test_extract_progress_messages_empty_data(self, session_ops):
        """测试处理空数据的 progress 消息"""
        raw_messages = [
            {"type": "progress", "parentToolUseID": "call_123", "data": {}},
            {
                "type": "progress",
                "parentToolUseID": "call_456",
                "data": {"normalizedMessages": []},
            },
        ]

        result = session_ops._extract_progress_messages(raw_messages)

        # 空的 progress 消息不应该产生 subagent 消息
        assert len(result) == 2
        assert len(result["call_123"]) == 0
        assert len(result["call_456"]) == 0

    def test_extract_progress_messages_no_parent_tool_use_id(self, session_ops):
        """测试没有 parentToolUseID 的 progress 消息"""
        raw_messages = [
            {
                "type": "progress",
                # 缺少 parentToolUseID
                "data": {
                    "normalizedMessages": [
                        {
                            "type": "user",
                            "uuid": "msg-1",
                            "message": {"role": "user", "content": "test"},
                        }
                    ]
                },
            }
        ]

        result = session_ops._extract_progress_messages(raw_messages)

        # 没有 parentToolUseID 的消息应该被忽略
        assert len(result) == 0

    @pytest.mark.asyncio
    async def test_merge_tool_result_with_subagent_messages(self, session_ops):
        """测试 tool_result 合并与 subagent 消息插入"""
        # 准备测试数据，包含 progress 消息
        raw_messages = [
            # Assistant 消息，包含 Task tool_use
            {
                "type": "assistant",
                "timestamp": "2024-01-01T10:00:00Z",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_use",
                            "id": "call_123",
                            "name": "Task",
                            "input": {
                                "subagent_type": "test_agent",
                                "description": "Test task description",
                            },
                        }
                    ],
                },
            },
            # Progress 消息，包含 subagent 对话
            {
                "type": "progress",
                "parentToolUseID": "call_123",
                "timestamp": "2024-01-01T10:00:01Z",
                "data": {
                    "normalizedMessages": [
                        {
                            "type": "user",
                            "uuid": "msg-1",
                            "timestamp": "2024-01-01T10:00:00Z",
                            "message": {"role": "user", "content": "Subagent task"},
                        },
                        {
                            "type": "assistant",
                            "uuid": "msg-2",
                            "timestamp": "2024-01-01T10:00:01Z",
                            "message": {
                                "role": "assistant",
                                "content": [
                                    {"type": "text", "text": "Subagent response"}
                                ],
                            },
                        },
                    ]
                },
            },
            # User 消息，包含 tool_result
            {
                "type": "user",
                "timestamp": "2024-01-01T10:00:02Z",
                "message": {
                    "role": "user",
                    "content": [
                        {
                            "type": "tool_result",
                            "tool_use_id": "call_123",
                            "content": "Task completed",
                        }
                    ],
                },
            },
        ]

        # 执行合并（_merge_tool_use_with_result 会自动提取 progress 消息）
        merged = session_ops._merge_tool_use_with_result(raw_messages)

        # 验证基本结构：应该有 2 条消息
        # 1. assistant with tool_use
        # 2. assistant with subagent content item
        assert len(merged) >= 2

        # 验证第一条消息是 assistant with tool_use
        assert merged[0]["type"] == "assistant"
        tool_use_content = merged[0]["message"]["content"]
        assert len(tool_use_content) == 1
        assert tool_use_content[0]["type"] == "tool_use"
        assert tool_use_content[0]["id"] == "call_123"
        assert tool_use_content[0]["output"] == "Task completed"
        assert tool_use_content[0]["status"] == "complete"

        # 验证第二条消息是 assistant with subagent content item
        assert merged[1]["type"] == "assistant"
        assert merged[1]["_is_subagent_wrapper"] is True
        subagent_content = merged[1]["message"]["content"]
        assert len(subagent_content) == 1
        assert subagent_content[0]["type"] == "subagent"
        assert subagent_content[0]["agent_type"] == "test_agent"
        assert subagent_content[0]["description"] == "Test task description"

        # 验证包含 ClaudeSession 对象
        assert "session" in subagent_content[0]
        session = subagent_content[0]["session"]
        assert session["session_id"] == "call_123"
        assert session["title"] == "Test task description"
        assert session["message_count"] == 2
        assert len(session["messages"]) == 2

        # 验证 session 中的消息是 ClaudeMessage 格式
        msg1 = session["messages"][0]
        assert msg1["timestamp"] == "2024-01-01T10:00:00Z"
        assert msg1["message"]["role"] == "user"
        # 字符串类型的 content 会被转换为 [{type: "text", text: "..."}] 格式
        msg1_content = msg1["message"]["content"]
        assert isinstance(msg1_content, list)
        assert msg1_content[0]["type"] == "text"
        assert msg1_content[0]["text"] == "Subagent task"

        msg2 = session["messages"][1]
        assert msg2["timestamp"] == "2024-01-01T10:00:01Z"
        assert msg2["message"]["role"] == "assistant"
        assert isinstance(msg2["message"]["content"], list)

    @pytest.mark.asyncio
    async def test_clean_system_tags_in_session_loading(self, temp_session_dir):
        """测试在 session 加载时清理系统标签并转换为标准格式"""
        session_file = temp_session_dir / "test-system-tags.jsonl"

        # 创建包含系统标签的 session
        messages = [
            {
                "type": "meta",
                "sessionId": "test-session",
                "timestamp": "2024-01-01T10:00:00.000Z",
            },
            {
                "type": "user",
                "timestamp": "2024-01-01T10:00:01.000Z",
                "message": {
                    "role": "user",
                    "content": """<local-command-caveat>Caveat: Messages below were generated while running local commands.</local-command-caveat>
<command-name>/clear</command-name>
<command-message>clear</command-message>
<command-args></command-args>
<local-command-stdout></local-command-stdout>
帮我调整 @.claude/commands/uiux_review.md 增加描述""",
                },
            },
            {
                "type": "assistant",
                "timestamp": "2024-01-01T10:00:02.000Z",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "text",
                            "text": "I'll help you adjust the command description.",
                        }
                    ],
                },
            },
        ]

        with open(session_file, "w", encoding="utf-8") as f:
            for msg in messages:
                f.write(json.dumps(msg) + "\n")

        # 加载 session
        ops = ClaudeSessionOperations(temp_session_dir)
        session, _ = await ops._load_session_data(session_file)

        assert session is not None
        assert session.message_count == 2

        # 验证第一条用户消息的内容已被清理并转换为标准格式
        user_msg = session.messages[0]
        assert user_msg.message["role"] == "user"
        content = user_msg.message["content"]

        # content 应该是列表格式
        assert isinstance(content, list)
        assert len(content) == 1
        assert content[0]["type"] == "text"

        # 系统标签应该被清理掉
        text_content = content[0]["text"]
        assert "<local-command-caveat>" not in text_content
        assert "<command-name>" not in text_content
        assert "<command-message>" not in text_content
        assert "<command-args>" not in text_content
        assert "<local-command-stdout>" not in text_content

        # 实际用户内容应该保留
        assert "帮我调整 @.claude/commands/uiux_review.md" in text_content
        assert "增加描述" in text_content

    @pytest.mark.asyncio
    async def test_merge_tool_result_with_subagent_messages(self, session_ops):
        """测试 tool_result 合并与 subagent 消息插入"""
        # 准备测试数据，包含 progress 消息
        raw_messages = [
            # Assistant 消息，包含 Task tool_use
            {
                "type": "assistant",
                "timestamp": "2024-01-01T10:00:00Z",
                "message": {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_use",
                            "id": "call_123",
                            "name": "Task",
                            "input": {
                                "subagent_type": "test_agent",
                                "description": "Test task description",
                            },
                        }
                    ],
                },
            },
            # Progress 消息，包含 subagent 对话
            {
                "type": "progress",
                "parentToolUseID": "call_123",
                "timestamp": "2024-01-01T10:00:01Z",
                "data": {
                    "normalizedMessages": [
                        {
                            "type": "user",
                            "uuid": "msg-1",
                            "timestamp": "2024-01-01T10:00:00Z",
                            "message": {"role": "user", "content": "Subagent task"},
                        },
                        {
                            "type": "assistant",
                            "uuid": "msg-2",
                            "timestamp": "2024-01-01T10:00:01Z",
                            "message": {
                                "role": "assistant",
                                "content": [
                                    {"type": "text", "text": "Subagent response"}
                                ],
                            },
                        },
                    ]
                },
            },
            # User 消息，包含 tool_result
            {
                "type": "user",
                "timestamp": "2024-01-01T10:00:02Z",
                "message": {
                    "role": "user",
                    "content": [
                        {
                            "type": "tool_result",
                            "tool_use_id": "call_123",
                            "content": "Task completed",
                        }
                    ],
                },
            },
        ]

        # 执行合并（_merge_tool_use_with_result 会自动提取 progress 消息）
        merged = session_ops._merge_tool_use_with_result(raw_messages)

        # 验证基本结构：应该有 2 条消息
        # 1. assistant with tool_use
        # 2. assistant with subagent content item
        assert len(merged) >= 2

        # 验证第一条消息是 assistant with tool_use
        assert merged[0]["type"] == "assistant"
        tool_use_content = merged[0]["message"]["content"]
        assert len(tool_use_content) == 1
        assert tool_use_content[0]["type"] == "tool_use"
        assert tool_use_content[0]["id"] == "call_123"
        assert tool_use_content[0]["output"] == "Task completed"
        assert tool_use_content[0]["status"] == "complete"

        # 验证第二条消息是 assistant with subagent content item
        assert merged[1]["type"] == "assistant"
        assert merged[1]["_is_subagent_wrapper"] is True
        subagent_content = merged[1]["message"]["content"]
        assert len(subagent_content) == 1
        assert subagent_content[0]["type"] == "subagent"
        assert subagent_content[0]["agent_type"] == "test_agent"
        assert subagent_content[0]["description"] == "Test task description"

        # 验证包含 ClaudeSession 对象
        assert "session" in subagent_content[0]
        session = subagent_content[0]["session"]
        assert session["session_id"] == "call_123"
        assert session["title"] == "Test task description"
        assert session["message_count"] == 2
        assert len(session["messages"]) == 2

        # 验证 session 中的消息是 ClaudeMessage 格式
        msg1 = session["messages"][0]
        assert msg1["timestamp"] == "2024-01-01T10:00:00Z"
        assert msg1["message"]["role"] == "user"
        # 字符串类型的 content 会被转换为 [{type: "text", text: "..."}] 格式
        msg1_content = msg1["message"]["content"]
        assert isinstance(msg1_content, list)
        assert msg1_content[0]["type"] == "text"
        assert msg1_content[0]["text"] == "Subagent task"

        msg2 = session["messages"][1]
        assert msg2["timestamp"] == "2024-01-01T10:00:01Z"
        assert msg2["message"]["role"] == "assistant"
        assert isinstance(msg2["message"]["content"], list)


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
